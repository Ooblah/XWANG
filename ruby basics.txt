Basic ruby

- Object oriented scripting language

Execute from command line
- ruby -e '...' (-e '...')
- -e only executes single line
- ruby filename

Comments
- # (single line comments)
- = ... = (block comments)

Dynamic typing
- a = 10
  b = 20
  c = 30
  c = 40
- support for parallel assignment
  a, b, c, d = 10, 20, 30, 40
- kind_of? Type (method returns boolean)
- class (method returns type)
- to_Type (method converts obj to Type: f, s, s(2), s(16), etc.)

Variable scope
- (begins with)
  $: global
  @: instance
  [a-z] or _: local
  [A-Z]: constant
  @@: class
- special variables
  $@: The location of latest error
  $_: The string last read by gets
  $.: The line number last read by interpreter
  $&: The string last matched by regexp
  $~: The last regexp match, as an array of subexpressions
  $n: The nth subexpression in the last match (same as $~[n])
  $=: The case-insensitivity flag
  $/: The input record separator
  $\: The output record separator
  $0: The name of the ruby script file currently executing
  $*: The command line arguments used to invoke the script
  $$: The Ruby interpreter's process ID
  $?: The exit status of last executed child process

Methods
- def name(...)
	...
  end

  name(...)

Ranges
- int..int (inclusive)
- int...int (exclusive)
- can be converted to an array method to_a
- range methods:
  min, max
	get lowest, highest value in range
  include?('...')
	checks if value exists in range
  reject {|subrange| subrange < '...'}
	rejects values satisfying condition
  each {|word| puts "Hello " + word}
	iterates and evaluates expression
- conditionals
  if x =~ /start/ .. x =~/end/
- check if x is in range (range) === x
- case statements
  score = 70
  result = case score
	when 0..40: "Fail"
	when question: answer
  	else answer
  end
  puts result

Arrays
- Array.new => create uninitialized array
- empty? method
- Array.new(n) => [nil, nil, ...] n times
- Array.new(n, "hi") => ["hi", ...] n times
- Array["hi", "ho", ...]
- Accessing arrays
  [0-(n-1)], at(0-(n-1))
  [-1] last element
  first, last
  index("hi")
  [1, 3], [1..3], slice(1..3) => multiple elements

Operations with arrays
- arr1 + arr2, arr1.concat(arr2) => concatenation
- arr << "hi" => append
- -, &, | => difference, intersection, union
- uniq, sort, reverse
- push "hi", pop
- == => returns boolean, eql?
- <=> => returns 0 if equal, -1 less, 1, greater
- arr.insert(1, "hi") inserts "hi" at index 1 and pushes everything after back
- can use index/ranges for assignment
- delete_at(n), delete("hi")

Operators
- 


